[参考文章](https://www.cnblogs.com/clover-toeic/p/3853132.html)
# 字节对齐 与 结构体大小
数据在内存中的存放，并不是简单的按照顺序紧挨着存放的。

## 对齐的原因和作用
* 不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。
* 但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。**每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。**
* 因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。

* 此外，合理利用字节对齐还可以有效地节省存储空间。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。
* 对于Intel X86平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量。

## 结构体对齐
### 对齐值
1. **数据类型有自身的对齐值即其字节大小**
2. **结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。**
3. **编译器有指定的对齐值，由编译指令#pragma pack (n)指定为n**
4. **数据成员、结构体和类的有效对齐值(实际使用的对齐值)为自身对齐值和指定对齐值中较小者min{自身对齐值，当前指定的pack值}。未指定则为其本身**  

* **存放一个类型的变量时，其起始地址只能是其对齐值的整数倍。** 这点很重要。

### 结构体的大小
在结构体中，编译器为结构体的每个成员按照其自然边界(alignment)分配空间。**各成员按照它们被声明的顺序在内存中顺序存储**，第一个成员的地址和整个结构的地址相同。  
按照上述规定，结构体有以下特点：
* 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。（对应2）
* 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍（对应4），如有需要编译器会在成员之间加上填充字节(internal adding)。
* 结构体的总大小为结构体最宽基本类型成员大小的整数倍（对应2），如有需要编译器会在最末一个成员之后加上填充字节(trailing padding)。
#### 例：
```
//sizeof(A)->8 bytes
struct A{
    char a; //1 byte
    int b;  //4 bytes
};
//sizeof(B)->12 bytes
struct B{
    char a;
    int b;
    short c; //2 bytes
};
//sizeof(C)->8 bytes
struct C{
    char a;
    short b;
    int c;
}
```
![image](498A78EC457B473995C2B591E582A004)
* 数据结构的成员位置要兼顾成员之间的关系、数据访问效率和空间利用率。一般占用字节多的在前面，字节少的跟在后面。
### 排查对齐问题
* 编译器的字节序大小端设置；
* 处理器架构本身是否支持非对齐访问；
* 如果支持看设置对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。 

### 更改对齐方式
* 使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐；
* 使用伪指令#pragma pack()： 取消自定义字节对齐方式。
* (GCC特有语法)：
* __attribute((aligned (n)))： 让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。
* \_\_attribute\_\_ ((packed))： 取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。


## 栈内存中的对齐
与变量类型无关，统一对齐在4字节边界上（32位平台下）。


## 位域对齐
### 位域：
```c++
struct {
  type [member_name] : width;
};
```
* type: 如何解释位域的值，可以是int、unsigned int和bool（看编译器）
* width：位域中位的数量。
* 位域的使用：
    * 节省空间
    * 当需要把一结构体或联合映射成某预定的组织结构时。如需要访问字节内的特定位时。
* 位域的地址不能访问，因此不允许将&运算符用于位域。
* 之间可以穿插普通成员
* 位域可以不指定位域名，但不能访问无名的位域。
* 长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。

### 对齐规则：
1. 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止。
2. 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍。
3. 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，GCC采取压缩方式。
4. 如果位域字段之间穿插着非位域字段，则不进行压缩。
5. 整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。

